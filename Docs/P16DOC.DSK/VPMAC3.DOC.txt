
                     3.7. Запросы ВПО
                                                          25.09.90

     ВПО─запросы представляют собой  интерфейс  между  диспетчером 
ВПО с одной стороны, и эмуляторами и другими программами с  другой 
стороны. Запросы реализуют программы диспетчера,  выполняющиеся  в 
режиме	HALT.  Вызов  запроса  выполняется   путем   обращения	 к
соответствующему  регистру  (находящемуся  в  области  эмулируемых 
регистров) следующим образом:

     MOV  arg, @#Name

где
     Name ─ имя запроса (т.е. соответствующий адрес регистра);
     Arg  ─ аргумент или параметр, передаваемый запросу.

     Для программ на ассемблере в  файле  P16.MAC  содержатся  все
необходимые определения и макрокоманды для  запросов  к  ВПО.  Для 
включения  в  программу  этого  файла  рекомендуется  использовать 
следующую последовательность директив:

     ...
     .nlist
     .include  "p16.mac"
     .list
     ...

     В этом случае целесообразнее  использовать  макрокоманды  для 
вызовов ВПО:

     Name      arg

где
     Name ─ имя запроса (т.е. соответствующая макрокоманда);
     arg  ─ аргумент или параметр, передаваемый запросу.

     Если запросу необходимо передать более одного  аргумента,  то 
обычно для этой  цели  используются  универсальные  регистры  ПРЦ, 
начиная с r0. Если количество  аргументов  достаточно  велико,	то
обычно передается адрес таблицы, в которой размещаются аргументы.

     Некоторые запросы сообщают о возникшей  ошибке  установленным 
битом С слова состояния процессора. Если С═0, то  запрос  выполнен 
нормально. Если С═1, то обнаружена  ошибка  (r0  при  этом  обычно
содержит дополнительную информацию).

     В связи  с  некоторыми  особенностями  аппаратной  реализации 
обработки прерываний по обращениям к "эмулируемым регистрам" после 
инструкции   обращения   к   регистру─запросу   должна   следовать 
инструкция NOP. Во все	макрокоманды─запросы  инструкция  NOP  уже
включена.

┌───────┐
│ GET4K │ ─ захватить от 1 до 16 блоков 4К (из младшей памяти);
└───────┘
вызов:
	  n4k  ─ необходимое число блоков по 4К
	  mov  n4k, @#GET4K
макрос:
	  GET4K     n4k
выход:
     С═0, r0   ─ содержимое регистра диспетчера  памяти  для  ото─
                 бражения первого полученного блока;
     С═1       ─ нет свободной области памяти требуемого размера;

┌───────┐
│ GET8K │ ─ захватить . непрерывную  область  памяти  (из  старшей
└───────┘   памяти);
вызов:
	  n8k  ─ длина требуемой области в блоках 8К;
	  mov  n8k, @#GET8K
макрос:
	  GET8K     n8k
выход:
     С═0, r0   ─ содержимое регистра диспетчера  памяти  для  ото─
                 бражения первого полученного блока;
     С═1, r0   ─ нет свободного  памяти  достаточного  объема;	r0
                 содержит размер максимальной  свободной  области; 
		 r0═0, если нет памяти для создания битовой карты;

┌───────┐
│FREMEM │ ─ освободить непрерывную область памяти (блоками 8К);
├───────┤
│FRE4K	│ ─ освободить непрерывную область памяти (блоками 4К);
└───────┘
          Данные запросы освобождают только принадлежащую процессу 
          память
вызов:
	  bln  ─ содержимое регистра диспетчера памяти для отобра─
                 жения первого блока освобождаемой области памяти;
	  nk   ─ длина освобождаемой области в блоках по 8К / 4К;
	  mov  bln, r0
	  mov  nk,  @#FREMEM	   ; или     mov #nk, @#FRE4K
макрос:
	  FREMEM    nk		   ; или     FRE4K     nk
выход:
          нет;

┌───────┐
│PUTBMAP│ ─ запомнить битовую карту памяти процесса; если не  было
└───────┘   карты, то создает ее;
вызов:
	  map  ─ адрес таблицы, из которой будет скопирована бито─
                 вая карта памяти;
	  mov  map, @#PUTBMAP
макрос:
	  PUTBMAP   map
выход:
     С═0       ─ карта нормально записана;
     С═1       ─ нет памяти для создания карты;
┌───────┐
│GETBMAP│ ─ получить битовую карту памяти процесса;
└───────┘
вызов:
	  map  ─ адрес таблицы, куда будет помещена битовая  карта
                 памяти; для таблицы  рекомендуется  отводить  128 
                 байт (для ПЭВМ с 4М байт ОЗУ);
	  mov  map, @#GETBMAP
макрос:
	  GETBMAP   map
выход:
     С═0, r0   ─ битовая карта процесса считана; r0 содержит длину
                 карты в байтах;
     С═1       ─ процесс не имеет битовой карты памяти;

┌───────┐
│GETSMAP│ ─ получить битовую карту памяти системы;
└───────┘
вызов:
	  map  ─ адрес таблицы, куда будет помещена битовая  карта
                 памяти   системы;   для   таблицы   рекомендуется 
                 отводить 128 байт (для ПЭВМ с 4М байт ОЗУ);
	  mov  map, @#GETSMAP
макрос:
	  ПУЕЫЪФЗ   map
выход:
     r0        ─ битовая карта системы считана; r0 содержит длину
                 карты в байтах;

┌───────┐
│NEWROMP│ ─ создать новый процесс и поставить  его  в  очередь	на
└───────┘  .выполнение;
вызов:
	  saddr─ адрес запуска процесса; созданный  процесс  будет
                 иметь максимальный приоритет (077777); для нового 
		 процесса r0─r6, ur0─ur7 будут копией соответству─
                 ющих регистров процесса, выдавшего данный запрос;
	  mov  saddr, @#NEWROMP
макрос:
	  NEWROMP   saddr
выход:
     С═0, r0   ─ процесс создан;  r0  текущего	процесса  содержит
                 адрес  дескриптора   созданного   процесса;   для 
		 созданного  процесса  регистры   r0─r6,   ur0─ur7
                 являются   копией    соответствующих    регистров 
                 текущего процесса;
     С═1       ─ нет памяти для создания дескриптора процесса;

┌───────┐
│NEWPROC│ ─ создать новый процесс;
└───────┘
вызов:
	  desc ─ адрес копии  дескриптора  создаваемого  процесса;
	  umap ─ адрес копии карты памяти создаваемого процесса;
	  mov  umap, r0
	  mov  desc, @#GETSMAP
макрос:
	  NEWPROC   desc
выход:
     С═0       ─ процесс создан и поставлен в очередь на  выполне─ 
		 ние; r0 содержит адрес дескриптора процесса;
     С═1       ─ для создания процесса (дескриптора  иеили  карты) 
                 не хватает памяти;

┌───────┐
│KILPROC│ ─ "убить" процесс;  дескриптор  процесса  освобождается;
└───────┘   освобождается память,  занятая  процессом,	вектора  и
            регистры,  обслуживаемые  этим   процессом;   процессу 
            запрещено "убивать" самого себя; для этой  цели  можно 
            использовать процесс, входящий  в  Консоль─пульт  (см. 
            п.10);

вызов:
	  num  ─ номер дескриптора процесса в едином  списке  дес─
                 крипторов процессов;

	  mov  num, @#KILPROC
макрос:
	  KILPROC   num
выход:
          нет;

┌───────┐
│SETPRI │ ─ установить новый приоритет текущему процессу;
└───────┘
вызов:
	  pri  ─ числовое значение устанавливаемого приоритета;
	  mov  pri, @#SETPRI
макрос:
	  SETPRI    pri
выход:
          нет;

┌───────┐
│HIMPRI │ ─ изменить приоритет другому процессу;
└───────┘
вызов:
	  pri  ─ новый приоритет для процесса;
	  proc ─ адрес дескриптора процесса;
	  mov  proc, r0
	  mov  pri, @#HIMPRI
макрос:
	  HIMPRI    pri
выход:
          нет;

┌───────┐
│PROVEC │ ─ захватить вектор для последующей обработки прерывания;
└───────┘
вызов:
	  vec  ─ адрес вектора, который надо захватить;
	  par  ─ слово─параметр, которое будет помещено во  второе
                 слово вектора;
	  mov  par, r0
	  mov  vec, @#PROVEC
макрос:
	  PROVEC    vec
выход:
     С═0       ─ вектор захвачен нормально;
     С═1, r0═0 ─ неправильно задан вектор;
	  r0<>0─ адрес процесса, захватившего вектор ранее;

┌───────┐
│UNPVEC │ ─ освободить вектор прерывания;
└───────┘
вызов:
	  vec  ─ адрес вектора, который надо освободить;
	  mov  vec, @#UNPVEC
макрос:
	  UNPVEC    vec
выход:
     С═0       ─ вектор освобожден;
     С═1       ─ неправильно задан вектор;

┌───────┐
│PROREG │ ─ захватить регистр для последующей эмуляции;
└───────┘
вызов:
	  rtbl ─ адрес таблицы	описания  регистра,  который  надо
                 захватить (см. дескриптор регистра);
		 rtbl:	 .word	 reg	;адрес регистра
			 .word	 mask	;маска разрядов r/o
			 .word	 copy	;копия разрядов r/o
			 .word	 stat	;правила обработки
		 (+)	 .word	 adr	;адрес подпрограммы
			 .word	 strt	;дополнительная информация
			 .word	 rese	;слово для копирования
					; по INIT-прерыванию
     Слово, помеченное (+), должно указываться,  если  в  качестве 
эмулятора будет использоваться подпрограмма (режима  HALT),  а	не
процесс.

	  mov  rtbl, @#PROREG
макрос:
	  PROREG    rtbl
выход:
     С═0, r0   ─ адрес	ячейки	R.COPY	дескриптора   захваченного
                 регистра;
     С═1, r0═0 ─ нет памяти для дескриптора регистра;
	  r0<>0─ адрес процесса, захватившего регистр ранее;

┌───────┐
│UNPREG │ ─ освободить эмулируемый регистр;
└───────┘
вызов:
	  reg  ─ адрес регистра, который надо освободить;
	  mov  reg, @#UNPREG
макрос:
	  UNPREG    reg
выход:
          нет;

┌───────┐
│WAITINT│ ─ ждать  прерывания  по  вектору  или  тайм─ауту  иеили
└───────┘   регистру эмулятора;
вызов:
	  mask ─ маска для запрета возможных прерываний в процессе
                 обработки   одного   из   них;   эта   же   маска 
                 используется для разрешения  прерываний,  которых 
                 ждет процесс;
		 если в маске установлен разряд M.TIO, то  процесс
                 будет (помимо всего прочего)  ожидать  тайм─аута; 
		 интервал тайм─аута в тиках задается в r3, а в	r4
                 должен  задаваться  параметр,  который  в  случае 
		 наступления тайм─аута будет возвращен в r2;
	  mov  mask, @#WAITINT
макрос:
	  WAITINT   mask
выход:
	  r0,r1─ произошло прерывание по обращению  к  одному  или
                 двум  регистрам,  эмулируемым  данным  процессом; 
                 если не было обращений к  эмулируемым  регистрам, 
		 то r0 иеили r1 содержат те  же  значения,  что  и
		 перед запросом WAITINT; в противном случае  в	r0
		 иеили r1 содержится слово R.STRT соответствующего
                 дескриптора регистра (если оба регистра  содержат 
		 соответствующие R.STRT, то было два  обращения  к
                 эмулируемым регистрам;  если  один  из  регистров 
                 содержит  прежнее  значение,  то  другой  регистр 
		 содержит R.STRT дескриптора эмулируемого регистра
                 ─  было  только  одно  обращение  к   эмулируемым 
                 регистрам);
	  r2   ─ содержит адрес  вектора,  по  которому  произошло
                 прерывание, или, если  наступил  тайм─аут,  слово 
		 параметра (т.е. копию регистра r4);
┌───────┐
│SETINT │ ─ выставить запрос на векторное прерывание;
└───────┘
вызов:
	  vec  ─ адрес вектора, по которому должно произойти  пре─
		 рывание; вектор должен быть в пределах  от  V.LOW
		 до V.HIGH;
	  mov  vec, @#SETVEC
макрос:
	  SETINT    vec
выход:
          нет;

┌───────┐
│RESINT │ ─ снять запрос на векторное прерывание;
└───────┘
вызов:
	  vec  ─ адрес вектора, по которому снять прерывание;
	  mov  vec, @#RESINT
макрос:
	  RESINT    vec
выход:
          нет;

┌───────┐
│MTHLT	│ ─ пересылает слово из r0 в адресное пространство HALT;
└───────┘
вызов:
	  adr  ─ адрес в адресном пространстве HALT;

	  mov  X, r0	      ;r0 ─ слово, которое будет передано;
	  mov  adr, @#MTHLT
макрос:
	  MTHLT     adr
выход:
          нет;

┌───────┐
│MFHLT	│ ─ пересылает слово из адресного пространство HALT в r0;
└───────┘
вызов:
	  adr  ─ адрес в адресном пространстве HALT;

	  mov  adr, @#MFHLT
макрос:
	  MFHLT     adr
выход:
	  r0   ─ содержит слово, считанное из адресного  простран─
		 ства режима HALT;

┌───────┐
│INITSEM│ ─ создание и инициализация семафора;
└───────┘
вызов:
	  ival ─ начальное значение счетчика семафора;
	  mov  ival, @#INITSEM
макрос:
	  INITSEM   ival
выход:
     С═0, r0   ─ указатель на созданный семафор;
     С═1       ─ нет памяти для создания семафора;

┌───────┐
│RELSEM │ ─ освободить семафор;
└───────┘
вызов:
	  sem  ─ указатель на семафор, который больше не нужен;
	  mov  sem, @#RELSEM
макрос:
	  RELSEM    sem
выход:
          нет;

┌───────┐
│WAITSEM│ ─ дождаться разрешения семафора;
└───────┘
вызов:
	  sem  ─ указатель на семафор, который должен  быть  прой─
                 ден;
	  mov  sem, @#WAITSEM
макрос:
	  WAITSEM   sem
выход:
          нет;

┌───────┐
│SIGSEM │ ─ выдать разрешение семафору;
└───────┘
вызов:
	  sem  ─ указатель на семафор, который надо открыть;
	  mov  sem, @#SIGSEM
макрос:
	  SIGSEM    sem
выход:
          нет;

┌───────┐
│TIMEOFF│ ─ выключает учет времени процессора и  освобождает  пос─
└───────┘   ледний канал звукогенератора (после включения  питания
            учет времени процессора включен);
макрос:
	  TIMEOFF
┌───────┐
│TIMEON │ ─ включает учет времени процессора;
└───────┘
макрос:
	  TIMEON

┌───────┐
│GETPDS │ ─ прочитать дескриптор процесса;
└───────┘
вызов:
	  tadr ─ адрес	таблицы,  куда	будет  считан  дескриптор;
                 длина таблицы определяется  размером  дескриптора 
		 (PROLEN/2 слов)
	  r0   ─ адрес	 дескриптора   процесса,   который   нужно
		 прочитать; если r0 будет содержать  0,  то  будет
                 прочитан дескриптор процесса, который обратился к 
                 регистру, обслуживаемому данным процессом

	  mov  descr,r0       ;адрес дескриптора или 0
	  mov  tadr, @#GETPDS
макрос:
	  GETPDS    tadr
выход:
     С═0       ─ дескриптор скопирован в таблицу;
     С═1       ─ дескриптор не прочитан: неправильно  задан  адрес 
                 дескриптора

┌───────┐
│PUTPDS │ ─ записать дескриптор процесса;
└───────┘
вызов:
	  tadr ─ адрес таблицы, откуда будет взят  дескриптор  для
                 записи;  длина  таблицы   определяется   размером 
		 дескриптора (PROLEN/2 слов)
	  r0   ─ адрес	 дескриптора   процесса,   который   нужно
		 записать; если r0 будет  содержать  0,  то  будет
                 записан дескриптор процесса, который обратился  к 
                 регистру, обслуживаемому данным процессом

	  mov  descr,r0       ;адрес дескриптора или 0
	  mov  tadr, @#PUTPDS
макрос:
	  PUTPDS    tadr
выход:
     С═0       ─ дескриптор записан (из таблицы);
     С═1       ─ дескриптор не записан:  неправильно  задан  адрес 
                 дескриптора

┌───────┐
│GETRDS │ ─ прочитать дескриптор регистра;
└───────┘
вызов:
	  tadr ─ адрес	таблицы,  куда	будет  считан  дескриптор;
                 длина таблицы определяется  размером  дескриптора 
		 (REGLEN/2 слов)
	  r0   ─ адрес	 регистра,   дескриптор   которого   нужно
                 прочитать;

	  mov  reg, r0	     ;адрес регистра
	  mov  tadr, @#GETRDS
макрос:
	  GETRDS    tadr
выход:
     С═0       ─ дескриптор скопирован в таблицу;
     С═1       ─ дескриптор не прочитан: неправильно  задан  адрес 
                 регистра

┌───────┐
│PUTRDS │ ─ записать дескриптор регистра;
└───────┘
вызов:
	  tadr ─ адрес	 таблицы,   из	 которой   будет   записан
                 дескриптор; длина таблицы  определяется  размером 
		 дескриптора (REGLEN/2 слов)
	  r0   ─ адрес	 регистра,   дескриптор   которого   нужно
                 записать;

	  mov  reg, r0	     ;адрес регистра
	  mov  tadr, @#PUTRDS
макрос:
	  PUTRDS    tadr
выход:
     С═0       ─ дескриптор записан;
     С═1       ─ дескриптор не записан:  неправильно  задан  адрес 
                 регистра

┌───────┐
│GETPAR │ ─ прочитать мэппинг указанного процесса;
└───────┘   данный запрос аналогичен GETPDR: считывается  не  весь
	    дескриптор, а только содержимое регистров URx;
вызов:
	  tadr ─ адрес	таблицы,  куда	будет  считано	содержимое
		 регистров URx (8 слов);
	  r0   ─ адрес дескриптора  процесса,  чей  мэппинг  нужно
		 прочитать; если r0 будет содержать  0,  то  будет
		 прочитаны URx из  дескриптора	процесса,  который
                 обратился  к  регистру,   обслуживаемому   данным 
                 процессом

	  mov  descr,r0       ;адрес дескриптора или 0
	  mov  tadr, @#GETPDS
макрос:
	  GETPDS    tadr
выход:
     С═0       ─ URx скопированы в таблицу

     С═1       ─ URx  не  прочитаны:   неправильно   задан   адрес
                 дескриптора

┌───────┐
│PUTPAR │ ─ записать мэппинг указанного процесса;
└───────┘   данный запрос аналогичен PUTPDR: записывается не  весь
	    дескриптор, а только содержимое регистров URx;
вызов:
	  tadr ─ адрес	 таблицы,   из	 которой   будет   считано
		 содержимое регистров URx (8 слов);
	  r0   ─ адрес дескриптора  процесса,  чей  мэппинг  нужно
		 записать; если r0 будет  содержать  0,  то  будут
		 записаны URx  из  дескриптора	процесса,  который
                 обратился  к  регистру,   обслуживаемому   данным 
                 процессом

	  mov  descr,r0       ;адрес дескриптора или 0
	  mov  tadr, @#PUTPDS
макрос:
	  PUTPDS    tadr
выход:
     С═0       ─ URx записаны из таблицы;
     С═1       ─ URx  не   записаны:   неправильно   задан   адрес
                 дескриптора

          3.8. Страница ввода/вывода

     Физические регистры

161000	PICCSR	КР580ВН59А
161002	PICMR	─ КОНТРОЛЛЕР ПРЕРЫВАНИЙ

161010	SNDC0R	К580ВИ53
161012	SNDC1R	─ ПРОГРАММИРУЕМЫЙ ТАЙМЕР
161014	SNDC2R
161016	SNDCSR
161020	SNLC0R	К580ВИ53
161022	SNLC1R	─ ПРОГРАММИРУЕМЫЙ ТАЙМЕР
161024	SNLC2R
161026	SNLCSR

161030	PPIA	К580ВВ55А
161032	PPIB	─ ПРОГРАММИРУЕМЫЙ
161034	PPIC	  ПАРАЛЛЕЛЪНЫЙ
161036	PPIP	  ИНТЕРФЕЙС

161040	HD.BUF	КР1809ВГ7
161042	HD.ERR	─ КОНТРОЛЛЕР НЖМД
161044	HD.SCNT
161046	HD.SNUM
161050	HD.CNLO
161052	HD.CNHI
161054	HD.SDH
161056	HD.CSR

161060	DLBUF	КР580ВВ51А
161062	DLCSR	─ ПОСЛЕДОВАТЕЛЪНЫЙ ПОРТ


161064	KBDBUF	КР580ВВ79
161066	KBDCSR	─ КОНТРОЛЛЕР КЛАВИАТУРЫ

161070	FD.CSR	КР1810ВГ72А
161072	FD.BUF	─ КОНТРОЛЛЕР НГМД
161076	FD.CNT


     Запросы ВПО


174176	GET4K	    174212  HIMPRI	174142	INITSEM
174200	GET8K	    174154  PROVEC	174144	RELSEM
174202	FREMEM	    174156  UNPVEC	174146	WAITSEM
174174	FRE4K	    174160  PROREG	174150	SIGSEM
174204	PUTMAP	    174162  UNPREG	174224	GETPDS
174206	GETBMAP     174164  WAITINT	174226	PUTPDS
174210	GETSMAP     174170  SETINT	174230	GETRDS
174166	NEWROMP     174172  RESINT	174232	PUTRDS
174214	NEWPROC     174216  MTHLT	174234	GETPAR
174222	KILPROC     174220  MFHLT	174236	PUTPAR
174152	SETPRI

174000  перезапуск системы

     Эмуляторы и утилиты

177130 HFBUF ─ ЭМУЛЯТОР НГМД/НЖМД   177600 GCSR   ─ ГРАФИЧЕСКИЙ ДИСПЛЕЙ
 HDVEC═230, FDVEC═234
				    176200 MXX	  ─ МАНИПУЛЯТОР "МЫШЪ"
177144 MDCSR ─ ЭМУЛЯТОР 	    176202 MYY
177146 MDBUF   ЭЛЕКТРОННОГО	    176204 MCSR
177150 MDSIZ   ДИСКА		    176206 MCALL

176500 RCSR  ─ ЭМУЛЯТОР 	    176240 SNCSR  ─ ЗВУКОГЕНЕРАТОР
176502 RBUF    ПОСЛЕДОВАТЕЛЪНОГО    176242 SNBUF
176504 TCSR    ИНТЕРФЕЙСА
176506 TBUF			    177110 CLKREG ─ КАЛЕНДАРЪ─ЧАСЫ
 DLVEC═300
				    174100 DCHAR  ─ КЛАВИАТУРА И
177530 WCSR  ─ ОКОННАЯ СИСТЕМА	    174102 DSTRING   ИНДИКАТОР
177524 WMCSR ─ ОКОННЫЙ МЕНЕДЖЕР     174104 DVAL
				    174106 KSTRING
177564 DCSR  ─ ТЕКСТОВЫЙ	    174110 RESPON
177566 DBUF    ДИСПЛЕЙ		    177560 KBCSR
 DVEC═64			    177562 KBBUF
				     KBVEC═60
177174 HOLER ─ калькулятор
				    174052 CNSBUF ─ пульт
174060 FILCSR─ ФАЙЛОВЫЙ МОДУЛЪ	    174054 CNSKIL ─ Kill─Him
174062 FMCSR
174064 FCCSR


          3.9. Замечания

     1. В качестве операционной системы рекомендуется использовать 
ДОС, имеющую полную совместимость с  однозадачным  (SJ)  монитором
систем типа RT─11, РАФОС, ФОДОС, ОС─ДВК и т.п.
     Монитор ДОС  значительно  переработан  в  части  обслуживания 
"терминала":
     ─ в отличии от RT─11/SJ новый монитор правильно  принимает  с
       клавиатуры 8─разрядные коды и правильно выводит на  дисплей 
       8─разрядные коды символов;
     ─ вывод на дисплей выполняется без прерываний и оптимизирован 
       под аппаратно─программную архитектуру ПЭВМ;
     ─ размер резидентной части монитора  сократился  примерно  на 
       400 байт;
     ─ монитор размещается в файле DOS.SYS (а не RT11SJ.SYS);
     ─ для  "стандартных"  программ,  работающих  под  управлением 
       RT─11, скорость вывода информации возрасла в несколько раз;
     ─ разработан новый терминальный драйвер, оптимизированный для 
       нового монитора ДОС; драйвер находится в  файле  с  тем  же 
       именем, что и стандартный драйвер RT─11;
     ─ новый монитор может  работать  только  с  новым  драйвером; 
       Новый драйвер может работать только с новым монитором.

     2. Процессы, обслуживающие прерывания и эмулирующие регистры, 
должны иметь приоритет более высокий, чем  процессы,  использующие 
эмулируемые регистры.

     3.  При  обработке  прерывания  процессом   все   прерывания, 
обслуживаемые данным процессом, запрещаются диспетчером ВПО.

     4. Таймерные прерывания, обрабатываемые ВПО, всегда разрешены 
практически всегда. ДОС, для которой ВПО эмулирует сетевой таймер, 
может терять некоторые таймерные прерывания,  поскольку  некоторые 
процессы (в частности  оконная  подсистема  и  текстовый  дисплей) 
расходуют достаточно много процессорного времени, работая на более 
высоком приоритете (чем ДОС), что может  привести  к  "отставанию" 
системных часов в ДОС.

     5. ДОС работает на приоритете 0 и, в  силу  своей  идеологии, 
"подбирает" процессорное время, остающееся от остальных процессов. 
Поэтому, если процесс установил себе приоритет, меньший 0 (или ему 
установили), то этот процесс может никогда не получить  управления 
при работающей ДОС.
